/*부호 있는 자료형의 비트 연산*/
#include <stdio.h>

int main()
{
    unsigned char num1 = 131; // 1000 0011
    char num2 = -125; // 125 : 0111 1101 => 1의보수 -> 1000 0010 / 2의 보수 1000 0011 (이게 -125임)

    /*
    * num1은 unsigned char로 부호없는 자료형.
    * num2는 (signed) char로 부호 있는 자료형인데, 이런 경우 가장 첫번째 비트가 부호를 결정한다.
    * 첫번째 비트가 1이면 음수, 0이면 양수이다.
    * 부호 있는 자료형은 시프트 연산 후 빈 공간을 1로 채워준다. 
    */


    unsigned char num3;
    char num4;

    num3 = num1 >> 5;
    num4 = num2 >> 5; //1000 0011을 오른쪽으로 5번 이동
  
    printf("%u\n", num3); // 0000 0100 => 4 =>부호 없는 자료형은 shift연산을 할 때 빈자리가 0으로 채워진다.
    printf("%u\n", num4); // 1111 1100 => 부호 있는 '음수' 자료형은 shift연산을 할 때 빈자리가 1로 채워진다.

    /*
        1111 1100을 십진수로 변환하기(부호있는 자료형)

        1. 2의 보수이므로 -1을 해준다.
            1000 0011 -1 = 1000 0010

        2. 나온 수를 1의 보수로 만들어준다.(1의 보수를 만드는 방법은 반전하는 것)
            ~1000 0010 = 0111 1101

        3. 위의 결과를 십진수로 변환한다.
            64+32+16+8+4+1 = 125

        4. 위의 결과에 마이너스를 붙여준다.
            -1 * 125 = -125

        5. 결과 : -125

    */

    return 0;
}